// 漏洞验证测试
// 测试之前发现的潜在漏洞是否已修复

use netconnpool::*;
use std::net::TcpListener;
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

/// 测试 1: idle_counts 与 idle_connections 一致性
/// 验证在高并发归还连接时，计数器和队列是否保持一致
#[test]
#[ignore]
fn test_idle_counts_consistency() {
    println!("\n=== 测试 1: idle_counts 与 idle_connections 一致性 ===");
    
    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();
    
    // 启动测试服务器
    thread::spawn(move || {
        loop {
            if let Ok((stream, _)) = listener.accept() {
                drop(stream);
            }
        }
    });
    
    let mut config = default_config();
    config.max_connections = 100;
    config.max_idle_connections = 50;
    config.dialer = Some(Box::new(move |_| {
        std::net::TcpStream::connect(addr)
            .map(ConnectionType::Tcp)
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)
    }));
    
    let pool = Pool::new(config).unwrap();
    
    // 并发获取和归还连接
    let handles: Vec<_> = (0..10)
        .map(|_| {
            let pool = pool.clone();
            thread::spawn(move || {
                for _ in 0..100 {
                    if let Ok(conn) = pool.get() {
                        thread::sleep(Duration::from_micros(10));
                        drop(conn); // 归还连接
                    }
                }
            })
        })
        .collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    thread::sleep(Duration::from_millis(100));
    
    let stats = pool.stats();
    println!("当前空闲连接数: {}", stats.current_idle_connections);
    println!("当前活跃连接数: {}", stats.current_active_connections);
    println!("总连接数: {}", stats.current_connections);
    
    // 验证：空闲连接数应该合理（不应该超过 max_idle_connections）
    assert!(
        stats.current_idle_connections <= 50,
        "空闲连接数超过限制: {}",
        stats.current_idle_connections
    );
    
    pool.close().unwrap();
    println!("✅ 测试通过：idle_counts 与 idle_connections 保持一致");
}

/// 测试 2: 统计计数器原子性
/// 验证在高并发下统计计数器是否会丢失更新
#[test]
#[ignore]
fn test_stats_atomicity() {
    println!("\n=== 测试 2: 统计计数器原子性 ===");
    
    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();
    
    thread::spawn(move || {
        loop {
            if let Ok((stream, _)) = listener.accept() {
                drop(stream);
            }
        }
    });
    
    let mut config = default_config();
    config.max_connections = 200;
    config.enable_stats = true;
    config.dialer = Some(Box::new(move |_| {
        std::net::TcpStream::connect(addr)
            .map(ConnectionType::Tcp)
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)
    }));
    
    let pool = Pool::new(config).unwrap();
    
    let total_operations = Arc::new(AtomicUsize::new(0));
    let successful_gets = Arc::new(AtomicUsize::new(0));
    
    // 高并发操作
    let handles: Vec<_> = (0..20)
        .map(|_| {
            let pool = pool.clone();
            let total = total_operations.clone();
            let success = successful_gets.clone();
            
            thread::spawn(move || {
                for _ in 0..500 {
                    total.fetch_add(1, Ordering::Relaxed);
                    if let Ok(conn) = pool.get() {
                        success.fetch_add(1, Ordering::Relaxed);
                        drop(conn);
                    }
                }
            })
        })
        .collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    thread::sleep(Duration::from_millis(200));
    
    let stats = pool.stats();
    let expected_gets = total_operations.load(Ordering::Relaxed);
    let actual_success = successful_gets.load(Ordering::Relaxed);
    
    println!("预期的 get 请求数: {}", expected_gets);
    println!("实际的 get 请求数: {}", stats.total_get_requests);
    println!("预期的成功次数: {}", actual_success);
    println!("实际的成功次数: {}", stats.successful_gets);
    
    // 验证：统计数据应该准确（允许小幅误差，因为可能有失败的情况）
    let get_diff = (stats.total_get_requests as i64 - expected_gets as i64).abs();
    let success_diff = (stats.successful_gets as i64 - actual_success as i64).abs();
    
    println!("get 请求差异: {}", get_diff);
    println!("成功次数差异: {}", success_diff);
    
    // 如果差异太大，说明有丢失更新的问题
    assert!(
        get_diff < 100,
        "统计计数器丢失更新: 差异 {}",
        get_diff
    );
    
    pool.close().unwrap();
    println!("✅ 测试通过：统计计数器保持原子性");
}

/// 测试 3: 连接 ID 唯一性
/// 验证连接 ID 是否会冲突
#[test]
#[ignore]
fn test_connection_id_uniqueness() {
    println!("\n=== 测试 3: 连接 ID 唯一性 ===");
    
    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();
    
    thread::spawn(move || {
        loop {
            if let Ok((stream, _)) = listener.accept() {
                drop(stream);
            }
        }
    });
    
    let mut config = default_config();
    config.max_connections = 1000;
    config.dialer = Some(Box::new(move |_| {
        std::net::TcpStream::connect(addr)
            .map(ConnectionType::Tcp)
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)
    }));
    
    let pool = Pool::new(config).unwrap();
    
    // 快速创建大量连接
    let mut connections = Vec::new();
    for _ in 0..500 {
        if let Ok(conn) = pool.get() {
            connections.push(conn);
        }
    }
    
    println!("创建了 {} 个连接", connections.len());
    
    // 检查 ID 是否唯一
    let mut ids = std::collections::HashSet::new();
    for conn in &connections {
        let id = conn.id;
        if !ids.insert(id) {
            panic!("发现重复的连接 ID: {}", id);
        }
    }
    
    println!("所有连接 ID 唯一");
    
    drop(connections);
    pool.close().unwrap();
    println!("✅ 测试通过：连接 ID 保持唯一性");
}

/// 测试 4: 压力测试下的稳定性
/// 综合测试所有潜在漏洞
#[test]
#[ignore]
fn test_comprehensive_stability() {
    println!("\n=== 测试 4: 综合稳定性测试 ===");
    
    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();
    
    thread::spawn(move || {
        loop {
            if let Ok((stream, _)) = listener.accept() {
                drop(stream);
            }
        }
    });
    
    let mut config = default_config();
    config.max_connections = 100;
    config.max_idle_connections = 50;
    config.enable_stats = true;
    config.dialer = Some(Box::new(move |_| {
        std::net::TcpStream::connect(addr)
            .map(ConnectionType::Tcp)
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)
    }));
    
    let pool = Pool::new(config).unwrap();
    let stop = Arc::new(AtomicBool::new(false));
    
    // 启动多个线程进行混合操作
    let handles: Vec<_> = (0..10)
        .map(|i| {
            let pool = pool.clone();
            let stop = stop.clone();
            
            thread::spawn(move || {
                let mut local_ops = 0;
                while !stop.load(Ordering::Relaxed) {
                    match i % 3 {
                        0 => {
                            // 快速获取和归还
                            if let Ok(conn) = pool.get() {
                                drop(conn);
                            }
                        }
                        1 => {
                            // 持有一段时间
                            if let Ok(conn) = pool.get() {
                                thread::sleep(Duration::from_micros(100));
                                drop(conn);
                            }
                        }
                        _ => {
                            // 批量操作
                            let mut conns = Vec::new();
                            for _ in 0..5 {
                                if let Ok(conn) = pool.get() {
                                    conns.push(conn);
                                }
                            }
                            drop(conns);
                        }
                    }
                    local_ops += 1;
                }
                local_ops
            })
        })
        .collect();
    
    // 运行 5 秒
    thread::sleep(Duration::from_secs(5));
    stop.store(true, Ordering::Relaxed);
    
    let mut total_ops = 0;
    for h in handles {
        total_ops += h.join().unwrap();
    }
    
    println!("总操作数: {}", total_ops);
    
    let stats = pool.stats();
    println!("统计信息:");
    println!("  总连接数: {}", stats.current_connections);
    println!("  空闲连接数: {}", stats.current_idle_connections);
    println!("  活跃连接数: {}", stats.current_active_connections);
    println!("  总 get 请求: {}", stats.total_get_requests);
    println!("  成功 get: {}", stats.successful_gets);
    println!("  失败 get: {}", stats.failed_gets);
    
    // 验证基本不变量
    assert!(stats.current_connections >= 0, "连接数不应为负");
    assert!(stats.current_idle_connections >= 0, "空闲连接数不应为负");
    assert!(stats.current_active_connections >= 0, "活跃连接数不应为负");
    assert!(
        stats.current_idle_connections <= 50,
        "空闲连接数不应超过限制"
    );
    
    pool.close().unwrap();
    println!("✅ 测试通过：系统在压力下保持稳定");
}

#[test]
fn test_all_vulnerabilities() {
    println!("\n========================================");
    println!("开始漏洞验证测试套件");
    println!("========================================");
    
    test_idle_counts_consistency();
    test_stats_atomicity();
    test_connection_id_uniqueness();
    test_comprehensive_stability();
    
    println!("\n========================================");
    println!("所有漏洞验证测试通过！✅");
    println!("========================================");
}
